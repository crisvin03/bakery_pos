{% extends 'core/base.html' %}
{% block content %}

<style>
  :root {
    --primary-gradient: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    --success-gradient: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    --warning-gradient: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
    --card-shadow: 0 20px 40px rgba(16,24,40,.08);
    --border-color: rgba(16,24,40,.08);
  }

  /* Body background matching home.html */
  body {
    background: linear-gradient(135deg, #f5e6d3 0%, #faf5f0 100%);
    min-height: 100vh;
  }

  /* Add spacing below sticky navbar */
  .container {
    padding-top: 0.75rem;
  }

  .forecast-page {
    padding: 1rem 0;
  }

  .page-header {
    background: rgba(255,255,255,0.95);
    backdrop-filter: blur(20px);
    border-radius: 16px;
    padding: 1rem 1.5rem;
    margin-bottom: 1rem;
    border: 1px solid rgba(255,255,255,0.2);
  }

  .page-header h1 {
    font-weight: 800;
    font-size: 1.25rem;
    background: var(--primary-gradient);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 0.25rem;
  }

  .control-forecast-container {
    display: flex;
    gap: 1rem;
    margin-bottom: 1rem;
    align-items: stretch;
  }

  .control-panel {
    background: rgba(255,255,255,0.95);
    backdrop-filter: blur(20px);
    border-radius: 16px;
    padding: 1.5rem 2rem;
    margin-bottom: 0;
    border: 1px solid rgba(255,255,255,0.2);
    flex: 1;
  }

  .control-group {
    display: flex;
    align-items: flex-end;
    gap: 1.5rem;
    flex-wrap: wrap;
    justify-content: flex-start;
  }

  .control-item {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    flex: 0 0 auto;
    width: 200px;
  }

  .control-item label {
    font-weight: 600;
    color: #374151;
    font-size: 0.9rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    white-space: nowrap;
  }

  .control-item select,
  .control-item input {
    border: 2px solid var(--border-color);
    border-radius: 10px;
    padding: 0.75rem 1rem;
    font-size: 1.1rem;
    transition: all 0.2s;
    background: white;
    width: 100%;
    min-height: 48px;
  }

  .control-item select:focus,
  .control-item input:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }

  .btn-apply {
    background: var(--primary-gradient);
    border: none;
    color: white;
    padding: 0.75rem 1.5rem;
    border-radius: 10px;
    font-weight: 600;
    font-size: 1.05rem;
    cursor: pointer;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex: 0 0 auto;
    min-height: 48px;
    white-space: nowrap;
    align-self: flex-end;
    margin-left: auto;
  }

  .btn-apply:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(59, 130, 246, 0.3);
  }

  .btn-apply:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
  }

  .btn-export {
    background: white;
    border: 2px solid #20c997;
    color: #20c997;
    padding: 0.75rem 1.5rem;
    border-radius: 10px;
    font-weight: 600;
    font-size: 1.05rem;
    cursor: pointer;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    gap: 0.5rem;
    flex: 0 0 auto;
    min-height: 48px;
    white-space: nowrap;
    align-self: flex-end;
  }

  .btn-export:hover {
    background: var(--success-gradient);
    border-color: transparent;
    color: white;
    transform: translateY(-2px);
  }

  .chart-card {
    background: rgba(255,255,255,0.95);
    backdrop-filter: blur(20px);
    border-radius: 16px;
    padding: 1rem 1.5rem;
    margin-bottom: 1rem;
    border: 1px solid rgba(255,255,255,0.2);
  }

  .chart-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    flex-wrap: wrap;
    gap: 0.75rem;
  }

  .chart-title {
    font-weight: 700;
    font-size: 1rem;
    color: #1e293b;
  }

  .chart-legend {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
  }

  .legend-item {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    font-size: 0.8rem;
    color: #4b5563;
  }

  .legend-dot {
    width: 10px;
    height: 10px;
    border-radius: 50%;
  }

  .legend-dot.blue {
    background: #0d6efd;
  }

  .legend-dot.green {
    background: #20c997;
  }

  .chart-container {
    position: relative;
    height: 300px;
    margin-top: 0.5rem;
  }

  .forecast-stats-container {
    display: flex;
    gap: 1rem;
    margin-bottom: 1rem;
    align-items: stretch;
  }

  .stats-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
    gap: 1rem;
    margin-bottom: 0;
    flex: 1;
  }

  .stat-card {
    background: rgba(255,255,255,0.95);
    backdrop-filter: blur(20px);
    border-radius: 12px;
    padding: 1rem;
    border: 1px solid rgba(255,255,255,0.2);
    box-shadow: 0 2px 8px rgba(0,0,0,.05);
    transition: all 0.3s;
  }

  .stat-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 24px rgba(0,0,0,.1);
  }

  .stat-label {
    font-size: 0.75rem;
    color: #4b5563;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 0.35rem;
  }

  .stat-value {
    font-size: 1.4rem;
    font-weight: 800;
    background: var(--primary-gradient);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
  }

  .forecast-summary-card {
    background: var(--primary-gradient);
    color: white;
    border-radius: 12px;
    padding: 1rem 1.5rem;
    margin-bottom: 0;
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
    display: flex;
    align-items: center;
    gap: 1.5rem;
    flex-wrap: wrap;
    flex: 0 0 400px;
    min-width: 300px;
  }

  .forecast-summary-title {
    font-size: 0.85rem;
    font-weight: 600;
    opacity: 0.9;
    margin-bottom: 0;
    white-space: nowrap;
  }

  .forecast-summary-value {
    font-size: 1.5rem;
    font-weight: 800;
    margin-bottom: 0;
    white-space: nowrap;
  }

  .forecast-summary-desc {
    font-size: 0.8rem;
    opacity: 0.8;
    margin-bottom: 0;
    flex: 1;
    min-width: 200px;
  }

  .table-card {
    background: rgba(255,255,255,0.95);
    backdrop-filter: blur(20px);
    border-radius: 16px;
    padding: 1rem 1.5rem;
    border: 1px solid rgba(255,255,255,0.2);
  }

  .table-title {
    font-weight: 700;
    font-size: 0.95rem;
    color: #1e293b;
    margin-bottom: 1rem;
    display: flex;
    align-items: center;
    gap: 0.4rem;
  }

  .table {
    border-radius: 12px;
    overflow: hidden;
  }

  .table thead th {
    background: var(--primary-gradient);
    color: white;
    font-weight: 700;
    text-transform: uppercase;
    font-size: 0.75rem;
    letter-spacing: 0.5px;
    padding: 0.75rem;
    border: none;
  }

  .table tbody td {
    padding: 0.75rem;
    border-color: rgba(0,0,0,.05);
    vertical-align: middle;
    font-size: 0.9rem;
  }

  .table tbody tr:hover {
    background: rgba(59, 130, 246, 0.05);
  }

  .empty-state {
    text-align: center;
    padding: 2rem 1rem;
    color: #4b5563;
  }

  .empty-state svg {
    width: 48px;
    height: 48px;
    opacity: 0.5;
    margin-bottom: 0.75rem;
  }

  .loading-spinner {
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid rgba(255,255,255,.3);
    border-radius: 50%;
    border-top-color: white;
    animation: spin 0.8s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .notification {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 9999;
    min-width: 300px;
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,.2);
    animation: slideIn 0.3s ease-out;
  }

  @keyframes slideIn {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
  }

  @media (max-width: 768px) {
    .control-group {
      flex-direction: column;
      align-items: stretch;
    }
    
    .control-item {
      width: 100%;
      min-width: unset;
    }
    
    .control-item select,
    .control-item input {
      min-width: unset;
    }
    
    .btn-apply,
    .btn-export {
      width: 100%;
      justify-content: center;
    }
    
    .chart-container {
      height: 250px;
    }
    
    .stats-grid {
      grid-template-columns: 1fr;
    }
    
    .forecast-page {
      padding: 0.5rem 0;
    }
    
    .control-forecast-container {
      flex-direction: column;
    }
    
    .forecast-stats-container {
      flex-direction: column;
    }
    
    .forecast-summary-card {
      flex-direction: column;
      align-items: flex-start;
      gap: 0.75rem;
      min-width: unset;
      width: 100%;
    }
    
    .forecast-summary-desc {
      min-width: unset;
      width: 100%;
    }
  }

  @media (max-width: 992px) and (min-width: 769px) {
    .control-item {
      min-width: 130px;
    }
    
    .control-item select,
    .control-item input {
      min-width: 130px;
    }
  }
</style>

<div class="forecast-page">
  <!-- Page Header -->
  <div class="page-header">
    <h1>ðŸ“ˆ Sales Forecast & Analytics</h1>
    <p class="text-muted mb-0 small">Analyze sales trends and predict future revenue</p>
  </div>

  <!-- Control Panel and Forecast Summary Container -->
  <div class="control-forecast-container">
  <!-- Control Panel -->
  <div class="control-panel">
    <div class="control-group">
      <div class="control-item">
        <label>
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"/>
          </svg>
          Forecast Period
        </label>
        <select id="forecastPeriod" class="form-select">
          <option value="1">1 month</option>
          <option value="2">2 months</option>
          <option value="3">3 months</option>
          <option value="6">6 months</option>
          <option value="12">12 months</option>
        </select>
      </div>
      <div class="control-item">
        <label>
          <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
          </svg>
          Moving Average Window
        </label>
        <select id="maWindow" class="form-select">
          <option value="1">1 month</option>
          <option value="2">2 months</option>
          <option value="3">3 months</option>
          <option value="6">6 months</option>
        </select>
      </div>
      <button id="applyForecast" class="btn-apply">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
          <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/>
        </svg>
        Apply
      </button>
      <button id="exportForecast" class="btn-export">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
          <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z"/>
        </svg>
        Export
      </button>
    </div>
  </div>

  <!-- Forecast Summary -->
  <div class="forecast-summary-card" id="forecastSummary" style="display: none;">
    <div class="forecast-summary-title">ðŸ“Š Forecast Summary</div>
    <div class="forecast-summary-value" id="forecastTotal">â‚±0.00</div>
    <div class="forecast-summary-desc" id="forecastDesc">Expected revenue for the next 1 month</div>
    </div>
  </div>

  <!-- Statistics Grid -->
  <div class="forecast-stats-container">

  <!-- Statistics Grid -->
  <div class="stats-grid" id="statsGrid" style="display: none;">
    <div class="stat-card">
      <div class="stat-label">Total Revenue (Period)</div>
      <div class="stat-value" id="statTotal">â‚±0.00</div>
    </div>
    <div class="stat-card">
      <div class="stat-label">Average Monthly</div>
      <div class="stat-value" id="statAvg">â‚±0.00</div>
    </div>
    <div class="stat-card">
      <div class="stat-label">Best Month</div>
      <div class="stat-value" id="statBest">â‚±0.00</div>
      <div class="text-muted small mt-1" id="statBestDate"></div>
    </div>
    </div>
  </div>

  <!-- Main Chart -->
  <div class="chart-card">
    <div class="chart-header">
      <h3 class="chart-title">Revenue Trend & Quantity</h3>
      <div class="chart-legend">
      <div class="legend-item">
        <span class="legend-dot blue"></span>
        <span>Monthly Revenue</span>
      </div>
      <div class="legend-item">
        <span class="legend-dot green"></span>
        <span>Monthly Quantity Sold</span>
      </div>
      </div>
    </div>
    <div class="chart-container">
      <canvas id="forecastChart"></canvas>
    </div>
    <div id="chartEmpty" class="empty-state" style="display: none;">
      <svg viewBox="0 0 24 24" fill="currentColor">
        <path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/>
      </svg>
      <h5>No Sales Data Available</h5>
      <p class="text-muted">Start making sales to see forecast data here.</p>
    </div>
  </div>

  <!-- Top Sellers Table -->
  <div class="table-card">
    <h3 class="table-title">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
        <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
      </svg>
      Top Sellers (Last 60 Days)
    </h3>
    {% if top %}
    <div class="table-responsive">
      <table class="table table-hover">
        <thead>
          <tr>
            <th>Product</th>
            <th class="text-end">Quantity</th>
            <th class="text-end">Price</th>
            <th class="text-end">Revenue</th>
          </tr>
        </thead>
        <tbody>
          {% for r in top %}
          <tr>
            <td class="fw-semibold">{{ r.product }}</td>
            <td class="text-end">{{ r.qty }}</td>
            <td class="text-end">â‚±{{ r.avg_price|floatformat:2 }}</td>
            <td class="text-end fw-bold text-success">â‚±{{ r.revenue|floatformat:2 }}</td>
          </tr>
          {% endfor %}
        </tbody>
      </table>
    </div>
    {% else %}
    <div class="empty-state">
      <svg viewBox="0 0 24 24" fill="currentColor">
        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
      </svg>
      <h5>No Sales Data Yet</h5>
      <p class="text-muted">Start selling products to see top performers here.</p>
    </div>
    {% endif %}
  </div>
</div>

{{ history|json_script:"hist-json" }}
{{ quantity_history|json_script:"qty-json" }}

<script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
<script>
  // Parse data
  const histData = JSON.parse(document.getElementById('hist-json').textContent || '[]');
  const qtyData = JSON.parse(document.getElementById('qty-json').textContent || '[]');
  
  // Group data by month
  function groupByMonth(data) {
    const monthly = {};
    
    data.forEach(item => {
      // Handle date format - could be "YYYY-MM-DD" string or Date object
      let dateStr = item.date;
      if (typeof dateStr === 'string') {
        // Extract year-month from "YYYY-MM-DD" format
        const parts = dateStr.split('-');
        if (parts.length >= 2) {
          const monthKey = `${parts[0]}-${parts[1]}`;
          
          if (!monthly[monthKey]) {
            monthly[monthKey] = {
              date: monthKey,
              revenue: 0,
              quantity: 0
            };
          }
          
          monthly[monthKey].revenue += Number(item.revenue || 0);
          monthly[monthKey].quantity += Number(item.quantity || 0);
        }
      } else {
        // If it's a Date object, convert to string first
        const date = new Date(dateStr);
        const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
        
        if (!monthly[monthKey]) {
          monthly[monthKey] = {
            date: monthKey,
            revenue: 0,
            quantity: 0
          };
        }
        
        monthly[monthKey].revenue += Number(item.revenue || 0);
        monthly[monthKey].quantity += Number(item.quantity || 0);
      }
    });
    
    // Convert to array and sort by date
    return Object.values(monthly).sort((a, b) => a.date.localeCompare(b.date));
  }
  
  // Combine revenue and quantity data by date
  const dateMap = {};
  
  // Add revenue data
  histData.forEach(h => {
    const date = h.date;
    if (!dateMap[date]) {
      dateMap[date] = { date, revenue: 0, quantity: 0 };
    }
    dateMap[date].revenue = Number(h.revenue || 0);
  });
  
  // Add quantity data
  qtyData.forEach(q => {
    const date = q.date;
    if (!dateMap[date]) {
      dateMap[date] = { date, revenue: 0, quantity: 0 };
    }
    dateMap[date].quantity = Number(q.quantity || 0);
  });
  
  // Convert to array and group by month
  const combinedData = Object.values(dateMap);
  const monthlyData = groupByMonth(combinedData);
  
  // Format month labels (e.g., "Jan 2024")
  const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  
  // Get last 3 months from available data
  const last3Months = monthlyData.slice(-3);
  
  // Get the last month from the data to determine the most recent month
  let last3MonthsData = [];
  
  if (monthlyData.length > 0) {
    // Get the most recent month from the data
    const lastMonth = monthlyData[monthlyData.length - 1];
    const [lastYear, lastMonthNum] = lastMonth.date.split('-');
    const lastYearNum = parseInt(lastYear);
    const lastMonthIndex = parseInt(lastMonthNum) - 1; // Convert to 0-11
    
    // Create a map of available months for quick lookup
    const availableMonthsMap = {};
    monthlyData.forEach(m => {
      availableMonthsMap[m.date] = m;
    });
    
    // Generate last 3 months: 2 months ago, 1 month ago, most recent month from data
    for (let i = 2; i >= 0; i--) {
      // Calculate the month index (0-11)
      let monthIndex = lastMonthIndex - i;
      let year = lastYearNum;
      
      // Handle year rollover if month goes negative
      if (monthIndex < 0) {
        monthIndex += 12;
        year -= 1;
      }
      
      // Create month key in format "YYYY-MM"
      const month = monthIndex + 1; // Convert to 1-12
      const monthKey = `${year}-${String(month).padStart(2, '0')}`;
      
      if (availableMonthsMap[monthKey]) {
        last3MonthsData.push(availableMonthsMap[monthKey]);
      } else {
        // Add empty month with zero values
        last3MonthsData.push({
          date: monthKey,
          revenue: 0,
          quantity: 0
        });
      }
    }
  } else {
    // No data available, generate last 3 months from today
    const today = new Date();
    const currentYear = today.getFullYear();
    const currentMonth = today.getMonth();
    
    for (let i = 2; i >= 0; i--) {
      let monthIndex = currentMonth - i;
      let year = currentYear;
      
      if (monthIndex < 0) {
        monthIndex += 12;
        year -= 1;
      }
      
      const month = monthIndex + 1;
      const monthKey = `${year}-${String(month).padStart(2, '0')}`;
      
      last3MonthsData.push({
        date: monthKey,
        revenue: 0,
        quantity: 0
      });
    }
  }
  
  const labels = last3MonthsData.map(m => {
    const [year, month] = m.date.split('-');
    return `${monthNames[parseInt(month) - 1]} ${year}`;
  });
  const values = last3MonthsData.map(m => m.revenue);
  const qtyValues = last3MonthsData.map(m => m.quantity);
  
  const pesoFmt = new Intl.NumberFormat('en-PH', { style: 'currency', currency: 'PHP' });
  
  const hasData = values.length > 0;
  let forecastChart = null;
  
  // Initialize chart
  function initChart() {
    const ctx = document.getElementById('forecastChart');
    if (!ctx) return;
    
    const chartWrap = ctx.closest('.chart-container');
    const chartEmpty = document.getElementById('chartEmpty');
    
    if (!hasData) {
      chartWrap.style.display = 'none';
      if (chartEmpty) chartEmpty.style.display = 'block';
      return;
    }
    
    chartWrap.style.display = 'block';
    if (chartEmpty) chartEmpty.style.display = 'none';
    
    const grad = ctx.getContext('2d').createLinearGradient(0, 0, 0, 400);
    grad.addColorStop(0, 'rgba(13, 110, 253, 0.2)');
    grad.addColorStop(1, 'rgba(13, 110, 253, 0)');
    
    forecastChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: labels,
        datasets: [{
          label: 'Monthly Revenue',
          data: values,
          borderColor: '#0d6efd',
          backgroundColor: grad,
          fill: true,
          borderWidth: 2,
          tension: 0.35,
          pointRadius: 0,
          pointHoverRadius: 3,
          yAxisID: 'y'
        }, {
          label: 'Monthly Quantity Sold',
          data: qtyValues,
          borderColor: '#20c997',
          backgroundColor: 'rgba(32, 201, 151, 0.1)',
          fill: false,
          borderWidth: 2,
          tension: 0.25,
          pointRadius: 0,
          pointHoverRadius: 3,
          yAxisID: 'y1'
        }]
      },
      options: {
        maintainAspectRatio: false,
        responsive: true,
        interaction: { mode: 'index', intersect: false },
        plugins: {
          legend: { display: false },
          tooltip: {
            padding: 12,
            displayColors: true,
            callbacks: {
              label: function(context) {
                if (context.dataset.label === 'Monthly Revenue') {
                  return `${context.dataset.label}: ${pesoFmt.format(context.parsed.y || 0)}`;
                } else {
                  return `${context.dataset.label}: ${context.parsed.y || 0} units`;
                }
              }
            }
          }
        },
        scales: {
          x: {
            grid: { display: false },
            ticks: { font: { size: 11 } }
          },
          y: {
            type: 'linear',
            display: true,
            position: 'left',
            ticks: {
              callback: function(value) {
                return pesoFmt.format(value).replace('PHP', 'â‚±');
              },
              font: { size: 11 }
            },
            grid: { color: 'rgba(0,0,0,.05)' }
          },
          y1: {
            type: 'linear',
            display: true,
            position: 'right',
            ticks: {
              callback: function(value) {
                return value;
              },
              font: { size: 11 }
            },
            grid: { drawOnChartArea: false }
          }
        }
      }
    });
    
    updateStats();
    updateForecastSummary();
  }
  
  // Update statistics
  function updateStats() {
    if (!hasData) return;
    
    const total = values.reduce((a, b) => a + b, 0);
    const avg = total / values.length;
    let bestVal = -Infinity, bestIdx = -1;
    values.forEach((v, i) => { if (v > bestVal) { bestVal = v; bestIdx = i; } });
    
    document.getElementById('statTotal').textContent = pesoFmt.format(total);
    document.getElementById('statAvg').textContent = pesoFmt.format(avg);
    document.getElementById('statBest').textContent = pesoFmt.format(bestVal);
    document.getElementById('statBestDate').textContent = bestIdx >= 0 ? labels[bestIdx] : '';
    document.getElementById('statsGrid').style.display = 'grid';
  }
  
  // Update forecast summary
  function updateForecastSummary() {
    const forecastPeriod = parseInt(document.getElementById('forecastPeriod').value) || 1;
    const maWindow = parseInt(document.getElementById('maWindow').value) || 1;
    
    const newForecast = calculateForecast(forecastPeriod, maWindow);
    const total = newForecast.reduce((a, b) => a + b, 0);
    
    document.getElementById('forecastTotal').textContent = pesoFmt.format(total);
    const periodText = forecastPeriod === 1 ? 'month' : 'months';
    const windowText = maWindow === 1 ? 'month' : 'months';
    
    // Check if there's enough data for the selected window
    const availableData = monthlyData.length;
    const effectiveWindow = Math.min(maWindow, availableData);
    let descText = `Expected revenue for the next ${forecastPeriod} ${periodText} (based on ${effectiveWindow}-${effectiveWindow === 1 ? 'month' : 'months'} moving average)`;
    
    if (maWindow > availableData) {
      descText += ` - Note: Using available ${availableData} ${availableData === 1 ? 'month' : 'months'} of data`;
    }
    
    document.getElementById('forecastDesc').textContent = descText;
    document.getElementById('forecastSummary').style.display = 'block';
  }
  
  // Calculate forecast
  function calculateForecast(period, window) {
    if (!monthlyData || monthlyData.length === 0) {
      return Array(period).fill(0);
    }
    
    // Use available data, but limit window to available data length
    const availableData = monthlyData.length;
    const effectiveWindow = Math.min(window, availableData);
    
    // Get the last N months of data
    const lastVals = monthlyData.slice(-effectiveWindow).map(m => m.revenue || 0);
    
    // Calculate average
    const avg = lastVals.reduce((a, b) => a + b, 0) / Math.max(1, lastVals.length);
    
    // Return forecast for the requested period
    return Array(period).fill(Math.round(avg * 100) / 100);
  }
  
  // Update chart
  function updateChart() {
    if (!forecastChart || !hasData) return;
    
    forecastChart.data.labels = labels;
    forecastChart.data.datasets[0].data = values;
    forecastChart.data.datasets[1].data = qtyValues;
    
    forecastChart.update('active');
    updateForecastSummary();
    showNotification('âœ… Chart updated successfully!', 'success');
  }
  
  // Helper function to get jsPDF
  function getJsPDF() {
    if (window.jspdf && window.jspdf.jsPDF) {
      return window.jspdf.jsPDF;
    } else if (window.jsPDF) {
      return window.jsPDF;
    } else if (typeof jspdf !== 'undefined' && jspdf.jsPDF) {
      return jspdf.jsPDF;
    }
    return null;
  }
  
  // Setup controls
  function setupControls() {
    const periodEl = document.getElementById('forecastPeriod');
    const windowEl = document.getElementById('maWindow');
    const applyBtn = document.getElementById('applyForecast');
    const exportBtn = document.getElementById('exportForecast');
    
    if (!periodEl || !windowEl || !applyBtn || !exportBtn) {
      setTimeout(setupControls, 100);
      return;
    }
    
    applyBtn.addEventListener('click', function() {
      const originalHTML = this.innerHTML;
      this.innerHTML = '<div class="loading-spinner"></div> Applying...';
      this.disabled = true;
      
      setTimeout(() => {
        updateChart();
        this.innerHTML = originalHTML;
        this.disabled = false;
      }, 300);
    });
    
    periodEl.addEventListener('change', updateChart);
    windowEl.addEventListener('change', updateChart);
    
      exportBtn.addEventListener('click', function() {
      try {
        // Get jsPDF - wait a bit if not loaded yet
        let jsPDF = getJsPDF();
        if (!jsPDF) {
          // Wait up to 3 seconds for library to load
          let attempts = 0;
          const checkInterval = setInterval(() => {
            attempts++;
            jsPDF = getJsPDF();
            if (jsPDF) {
              clearInterval(checkInterval);
              generatePDF(jsPDF);
            } else if (attempts >= 30) {
              clearInterval(checkInterval);
              showNotification('âŒ PDF library failed to load. Please refresh the page.', 'danger');
            }
          }, 100);
          return;
        }
        
        generatePDF(jsPDF);
        
        function generatePDF(jsPDFClass) {
        const period = parseInt(periodEl.value) || 1;
          const maWindow = parseInt(windowEl.value) || 1;
          const forecast = calculateForecast(period, maWindow);
          
          // Helper function to format numbers without separators
          function formatNumber(num) {
            return num.toFixed(2);
          }
          
          // Helper function to format quantity without separators
          function formatQuantity(num) {
            return num.toString();
          }
          
          const currentDate = new Date();
          const totalHistorical = values.reduce((a,b) => a + b, 0);
          const totalForecast = forecast.reduce((a,b) => a + b, 0);
          const avgMonthly = values.length > 0 ? totalHistorical / values.length : 0;
          const totalQuantity = monthlyData.reduce((sum, item) => sum + item.quantity, 0);
          
          // Load logo first, then generate PDF
          const logoUrl = 'https://crisvin03.github.io/bakery_pos/static/images/logo.png';
          const logoSize = 20; // Height in points
          
          // Function to generate PDF with or without logo
          function createPDF(logoDataUrl, imgWidth, imgHeight) {
            // Create PDF using jsPDF
            const doc = new jsPDFClass();
            
            // Professional header section
            const pageWidth = doc.internal.pageSize.getWidth();
            const margin = 20;
            let yPos = margin;
            
            // Company header with line
            doc.setFillColor(59, 130, 246);
            doc.rect(0, 0, pageWidth, 30, 'F');
            
            // Add logo if available
            let textStartX = margin;
            if (logoDataUrl && imgWidth > 0 && imgHeight > 0) {
              try {
                const logoX = margin;
                const logoY = 5;
                const logoHeight = logoSize;
                // Calculate width maintaining actual aspect ratio
                const logoWidth = (logoHeight * imgWidth) / imgHeight;
                // Use PNG format to preserve transparency
                doc.addImage(logoDataUrl, 'PNG', logoX, logoY, logoWidth, logoHeight);
                textStartX = margin + logoWidth + 8;
              } catch (e) {
                console.log('Error adding logo to PDF:', e);
              }
            }
            
            // Add company name and title (positioned after logo)
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(20);
            doc.setFont(undefined, 'bold');
            doc.text('ALVAREZ BAKERY', textStartX, 15);
            
            doc.setFontSize(14);
            doc.setFont(undefined, 'normal');
            doc.text('Sales Forecast Report', textStartX, 22);
            
            // Reset text color
            doc.setTextColor(0, 0, 0);
            yPos = 45;
          
            // Report metadata
            doc.setFontSize(9);
            doc.setFont(undefined, 'normal');
            doc.text(`Generated: ${currentDate.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' })}`, margin, yPos);
            yPos += 5;
            doc.text(`Forecast Period: ${period} ${period === 1 ? 'Month' : 'Months'} | Moving Average: ${maWindow} ${maWindow === 1 ? 'Month' : 'Months'}`, margin, yPos);
            yPos += 10;
            
            // Draw separator line
            doc.setDrawColor(200, 200, 200);
            doc.line(margin, yPos, pageWidth - margin, yPos);
            yPos += 8;
            
            // Prepare table data
            const tableData = [];
            const maxLength = Math.max(monthlyData.length, forecast.length);
            
            for (let i = 0; i < maxLength; i++) {
              let periodText = '';
              let revenue = '';
              let quantity = '';
              let avgPrice = '';
              let forecasted = '';
              
              // Historical data
              if (i < monthlyData.length) {
                const item = monthlyData[i];
                const [year, month] = item.date.split('-');
                const monthName = monthNames[parseInt(month) - 1];
                periodText = `${monthName} ${year}`;
                revenue = `PHP ${formatNumber(item.revenue)}`;
                quantity = formatQuantity(item.quantity);
                avgPrice = `PHP ${formatNumber(item.quantity > 0 ? item.revenue / item.quantity : 0)}`;
              }
              
              // Forecast data
              if (i < forecast.length) {
                const forecastDate = new Date(currentDate);
                forecastDate.setMonth(currentDate.getMonth() + i + 1);
                const monthName = monthNames[forecastDate.getMonth()];
                const year = forecastDate.getFullYear();
                if (!periodText) periodText = `${monthName} ${year}`;
                forecasted = `PHP ${formatNumber(forecast[i])}`;
              }
              
              tableData.push([periodText, revenue, quantity, avgPrice, forecasted]);
            }
            
            // Table headers - shortened for better fit
            const headers = ['Period', 'Revenue', 'Quantity', 'Avg Price', 'Forecast'];
            
            // Calculate available width and adjust column widths proportionally
            const availableWidth = pageWidth - (margin * 2);
            const rowHeight = 7;
            // Proportional widths: Period, Revenue, Quantity, Avg Price, Forecast
            const colWidths = [
              availableWidth * 0.18,  // Period
              availableWidth * 0.22,  // Revenue
              availableWidth * 0.18,  // Quantity
              availableWidth * 0.22,  // Avg Price
              availableWidth * 0.20   // Forecast
            ];
            const startX = margin;
            const tableWidth = availableWidth;
            
            // Draw header row with professional styling
            doc.setFont(undefined, 'bold');
            doc.setFontSize(10);
            doc.setFillColor(40, 40, 40);
            doc.rect(startX, yPos - 5, tableWidth, rowHeight, 'F');
            doc.setTextColor(255, 255, 255);
            
            // Draw header borders
            doc.setDrawColor(60, 60, 60);
            doc.line(startX, yPos - 5, startX + tableWidth, yPos - 5); // Top
            doc.line(startX, yPos - 5, startX, yPos + rowHeight - 5); // Left
            doc.line(startX + tableWidth, yPos - 5, startX + tableWidth, yPos + rowHeight - 5); // Right
            
            let xPos = startX;
            headers.forEach((header, idx) => {
              // Center align headers and ensure they fit
              const textWidth = doc.getTextWidth(header);
              const cellCenter = xPos + colWidths[idx] / 2;
              doc.text(header, cellCenter - textWidth / 2, yPos);
              // Draw vertical separator
              if (idx < headers.length - 1) {
                doc.line(xPos + colWidths[idx], yPos - 5, xPos + colWidths[idx], yPos + rowHeight - 5);
              }
              xPos += colWidths[idx];
            });
            // Draw bottom border of header
            doc.line(startX, yPos + rowHeight - 5, startX + tableWidth, yPos + rowHeight - 5);
            
            // Draw data rows
            doc.setTextColor(0, 0, 0);
            doc.setFont(undefined, 'normal');
            doc.setFontSize(9);
            yPos += rowHeight;
            
            tableData.forEach((row, rowIdx) => {
              if (yPos > 270) {
                doc.addPage();
                yPos = margin + 10;
              }
              
              // Alternate row colors for better readability
              if (rowIdx % 2 === 0) {
                doc.setFillColor(250, 250, 250);
                doc.rect(startX, yPos - 5, tableWidth, rowHeight, 'F');
              }
              
              // Draw cell borders
              doc.setDrawColor(220, 220, 220);
              // Draw left border
              doc.line(startX, yPos - 5, startX, yPos + rowHeight - 5);
              // Draw vertical lines between columns
              xPos = startX;
              colWidths.forEach((width, colIdx) => {
                if (colIdx < colWidths.length - 1) {
                  xPos += width;
                  doc.line(xPos, yPos - 5, xPos, yPos + rowHeight - 5);
                }
              });
              // Draw right border
              doc.line(startX + tableWidth, yPos - 5, startX + tableWidth, yPos + rowHeight - 5);
              // Draw horizontal line at bottom
              doc.line(startX, yPos + rowHeight - 5, startX + tableWidth, yPos + rowHeight - 5);
              
              // Draw cell content
              xPos = startX;
              row.forEach((cell, colIdx) => {
                const cellText = cell || '';
                const cellWidth = colWidths[colIdx];
                const padding = 2;
                const maxTextWidth = cellWidth - (padding * 2);
                
                // Check if text fits, truncate if necessary
                let displayText = cellText;
                let textWidth = doc.getTextWidth(displayText);
                
                if (textWidth > maxTextWidth) {
                  // Truncate text to fit
                  while (textWidth > maxTextWidth && displayText.length > 0) {
                    displayText = displayText.slice(0, -1);
                    textWidth = doc.getTextWidth(displayText);
                  }
                  displayText = displayText.slice(0, -3) + '...';
                }
                
                // Right align numbers, left align text
                if (colIdx > 0 && cellText) {
                  // Right align for numeric columns
                  doc.text(displayText, xPos + cellWidth - textWidth - padding, yPos);
                } else {
                  // Left align for period column
                  doc.text(displayText, xPos + padding, yPos);
                }
                xPos += cellWidth;
              });
              
              yPos += rowHeight;
            });
            
            // Footer
            const totalPages = doc.internal.pages.length - 1;
            for (let i = 1; i <= totalPages; i++) {
              doc.setPage(i);
              doc.setFontSize(8);
              doc.setTextColor(128, 128, 128);
              doc.text(`Page ${i} of ${totalPages}`, pageWidth - margin - 20, doc.internal.pageSize.getHeight() - 10);
              doc.text(`Alvarez Bakery POS System`, margin, doc.internal.pageSize.getHeight() - 10);
            }
          
            // Save PDF
            doc.save(`Sales_Forecast_Report_${new Date().toISOString().split('T')[0]}.pdf`);
            
            showNotification('ðŸ“¥ Forecast data exported successfully!', 'success');
          }
          
          // Load logo image
          const img = new Image();
          img.crossOrigin = 'anonymous';
          
          img.onload = function() {
            try {
              const canvas = document.createElement('canvas');
              canvas.width = this.width;
              canvas.height = this.height;
              const ctx = canvas.getContext('2d');
              
              // Clear canvas to ensure transparency
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              
              // Draw image preserving transparency
              ctx.drawImage(this, 0, 0);
              
              // Use PNG format to preserve transparency
              const logoDataUrl = canvas.toDataURL('image/png');
              // Pass image dimensions for proper aspect ratio
              createPDF(logoDataUrl, this.width, this.height);
            } catch (e) {
              console.log('Error processing logo:', e);
              createPDF(null, 0, 0);
            }
          };
          
          img.onerror = function() {
            console.log('Logo could not be loaded, continuing without logo');
            createPDF(null, 0, 0);
          };
          
          img.src = logoUrl;
        }
      } catch (error) {
        console.error('Export error:', error);
        showNotification('âŒ Error generating PDF: ' + error.message, 'danger');
      }
    });
  }
  
  // Show notification
  function showNotification(message, type = 'info') {
    const existing = document.querySelectorAll('.notification');
    existing.forEach(n => n.remove());
    
    const notification = document.createElement('div');
    notification.className = `notification alert alert-${type} alert-dismissible fade show`;
    notification.innerHTML = `
      <div class="d-flex align-items-center">
        <div class="me-2">${message}</div>
        <button type="button" class="btn-close ms-auto" data-bs-dismiss="alert"></button>
      </div>
    `;
    
    document.body.appendChild(notification);
    
    setTimeout(() => {
      if (notification.parentNode) {
        notification.classList.remove('show');
        setTimeout(() => notification.remove(), 300);
      }
    }, 4000);
  }
  
  // Initialize
  document.addEventListener('DOMContentLoaded', function() {
    initChart();
    setupControls();
  });
</script>

{% endblock %}
